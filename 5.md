# Задача 5 (5.9137)

### Решение со словарем
Нас просят сгенерировать тупл, содержащий с n-го по (n + k - 1)-е число Фибоначчи. Зная n-е и (n + 1)-е число Фибоначии, несложно сгенерировать оставшиеся. Идея заключается в том, чтобы подсмотреть эти стартовые числа в словаре, вообще не считая их в рантайме, а оставшиеся сгенерить с помощью очень эффективного ассемблерного цикла.

Это приводит к такому решению:
```
tuple solution(int n, int k) asm """
  variable dict
  variable pos
  dictnew dict !
  0 pos !
  { pos @ 1+ pos ! } : inc-pos
  { <{ rot PUSHINT swap PUSHINT }>s pos @ dict @ 9 udict! drop dict ! inc-pos } : add-fib
  0 1 {
  2dup add-fib
  tuck +
  } 369 times add-fib
  94611056096305838013295371573764256526437182762229865607320618320601813254535 constant 370Fib
  370Fib 0 add-fib

  //  n k
  TUCK 0 EQINT	
  IFJMP:<{ 2DROP NIL }>

  dict @ 9 DICTPUSHCONST DICTUGETEXEC ROT	// a b k

  DUP 1 EQINT 
  IFJMP:<{ 2DROP SINGLE }>

  DEC DEC REPEAT:<{
      2DUP ADD
  }>
  DEPTH TUPLEVAR
""";
```

Здесь в первой половине написан код на Fift, генерирующий словарь. Я использую небольшой трюк: вместо того, чтобы в качестве значений по ключу n просто хранить числа `F_n` и `F_{n + 1}`, я храню слайс, кодирующий пару инструкций вида `F_n PUSHINT F_{n + 1} PUSHINT`. Это позволяет получить значение из словаря с помощью примитива `DICTUGETEXEC`.

Дальше идет непосредственно код для TVM. Здесь мы отдельно обрабатываем случай k = 0, дальше получаем значение из словаря. Отдельно обрабатываем случай k = 1, чтобы избежать проблем с переполнениями. Затем k-2 раза выполняем `2DUP ADD`, оставляя на стеке как раз все числа Фибоначчи с `F_n` до `F_{n + k - 1}`. После чего с помощью `DEPTH TUPLEVAR` пакуем их в тупл.

Это решение набирает **5.9106** баллов.

### Трюк с IFBITJMPREF
При чтении значения из словаря мы на каждой развилке переходим в новую ячейку, что стоит нам как минимум 100 единиц газа на подгрузку этой ячейки. Но в TVM есть примитив `IFBITJMPREF`: 
> IFBITJMPREF n (x – x), performs a JMPREF if bit 0 ≤ n ≤ 31
is set in integer x.

С его помощью можно построить аналог словаря непосредственно на структуре дерева ячеек, хранящего наш исполняемый код. А именно, будем так же, как и обычный словарь, проверять значения бит нашего числа n, от старшего к младшему. Когда дойдем до самого младшего, мы уже будем знать, чему равно n, и сможем выполнить нужные `F_n PUSHINT F_{n + 1} PUSHINT`. Плюс этого примитива заключается в том, что переходим в новую ячейку мы только в половине случаев -- во второй половине мы просто продолжаем исполнение кода из текущей ячейки. Конечно, в одной ячейке не может быть больше 3 примитивов `IFBITJMPREF`, поэтому каждый третий раз мы всё равно неявно будем подгружать новую ячейку с кодом. Тем не менее, такой способ в среднем немного дешевле обычного чтения из словаря.

Напишем небольшой скрипт на питоне, чтобы сгенерировать нужный ассемблерный код:
```
def gen_dict(n):
    a = 0
    b = 1
    res = {}
    for i in range(n + 1):
        res[i] = a
        a, b = b, a + b
    res[371] = 0
    return res

def gen_asm(dict, bits, l, x):
    if bits == l:
        if x in dict and x + 1 in dict:
            return "DROP " + str(dict[x]) + " PUSHINT " + str(dict[x + 1]) + " PUSHINT"
        else:
            return ""

    r0 = gen_asm(dict, bits + 1, l, x * 2)
    r1 = gen_asm(dict, bits + 1, l, x * 2 + 1)

    if r0 == "":
        return r1
    if r1 == "":
        return r0

    return "<{ " + r1 + " }>c " + str(l - 1 - bits) + " IFBITJMPREF " + r0

d = gen_dict(370)
table = gen_asm(d, 0, 9, 0)
print(table)
```

Итоговое решение выглядит вот так:

```
tuple solution(int n, int k) asm """
  <{ [вывод нашего скрипта] }> constant table-code
    
  //  n k
  TUCK 0 EQINT	
  IFJMP:<{ 2DROP NIL }>

  table-code PUSHCONT EXECUTE ROT	// a b k

  DUP 1 EQINT 
  IFJMP:<{ 2DROP SINGLE }>

  DEC DEC REPEAT:<{
      2DUP ADD
  }>
  DEPTH TUPLEVAR
""";
```

Оно набирает **5.9137** баллов.

### Можно ли лучше?

Во-первых, можно проверять биты числа n в другом порядке, или использовать IFNBITJMPREF в некоторых развилках. Это может позволить уменьшить среднее время обращение к словарю (которое, впрочем, также зависит от распределения n во входных данных).

Во-вторых, можно бы было использовать трюк с 
```
}> }END>c drop <{
*your code here*
}>c 2 boc+>B "res" B>file bye
```

чтобы перезаписать стандартный поиск нужного метода в словаре, что позволит также немного улучшить счет.