# Задача 1 (5.5481)

Нас просят найти ячейку с заданным хешем в дереве ячеек, и ничего лучше подобия dfs сделать, по всей видимости, нельзя. Вопрос в эффективности реализации этого dfs. 

### Идея 1
Давайте сразу откажемся от рекурсии и будет явно хранить стек вершин, которые мы хотим посетить, и обрабатывать их в цикле. Стек можно эффективно хранить в list-style списке на туплах.

```
(cell) find_branch_by_hash(int hash, cell cur) method_id {
    tuple t = cons(cur, null());
    do {
        cell c = t~list_next();
        if (hash == cell_hash(c)) {
            return c;
        } else {
            slice cs = c.begin_parse();
            repeat (cs.slice_refs()) {
                t = cons(cs~load_ref(), t);
            }
        }
    } until t.null?();
    return begin_cell().end_cell();
}
```
Стоит отметить, что тут мы используем `repeat (cs.slice_refs())`, а не `while (cs.slice_refs())` -- это заметно дешевле по газу, поскольку TVM не приходится проверять условие цикла на каждой итерации.

Такое решение набирает **5.395** баллов и съедает **1597202** газа.

### Идея 2
Заметим, что у нас есть два способа выйти из этого цикла: по `return c`, когда мы нашли нужную ячейку, и по условию цикла `t.null?()`, когда в нашем стеке не осталось вершин. Что было бы, если бы вместо `do-until` цикла мы использовали `while (true)`? Если ответ на задачу положительный, то ничего бы не изменилось, мы бы по-прежнему нашли нужную ячейку и вернули её. А если такой ячейки нет, то TVM в какой-то момент бросит исключение, когда мы попытается вызвать `~list_next()` от `null`. 

Но ведь исключения можно ловить! Давайте запустим бесконечный цикл, и если в какой-то момент он упадет с исключением -- поймаем это исключение и вернем пустую ячейку. Так мы сможем избавиться от лишней проверки на `t.null?()` в конце цикла.

Для этого уже придется перейти на ассемблер, но за основу мы возьмем вывод FunC на нашем коде и немного его модифицируем.

```
cell solution(int hash, cell cur) asm """
    PUSHNULL	//  hash cur _3
    CONS	//  hash t
    <{ 
      AGAINBRK:
      UNCONS	//  hash c t
      OVER	//  hash c t c
      HASHCU	//  hash c t _8
      s3 s(-1) PUXC	//  hash c t hash _8
      EQUAL	//  hash c t _9
      IFJMP:<{	//  hash c t
        DROP
        NIP	//  c
        RETALT
      }>	//  hash c t
      SWAP	//  hash t c
      CTOS	//  hash t cs
      DUP	//  hash t cs cs
      SREFS	//  hash t cs _12
      REPEAT:<{	//  hash t cs
        LDREF	//  hash t _13 cs
        s0 s2 XCHG	//  hash cs _13 t
        CONS	//  hash cs t
        SWAP	//  hash t cs
      }>
      DROP	//  hash t
    }>CONT	//  hash t
    <{ 2DROP	
       <b b> PUSHREF
    }>CONT
    TRY
""";
```

Здесь используется `TRY`-примитив, который как раз позволяет ловить исключения. Код в первом блоке `<{ ... }>CONT` это код нашего цикла, код во втором блоке `<{ ... }>CONT` это обработчик исключений. 

Здесь мы поменяли `UNTIL:<{ ... }>` цикл на `AGAINBRK:`. `AGAIN` это отдельный примитив, позволяющий запускать бесконечные циклы. Суффикс `BRK` дает нам возможность выйти из бесконечного цикла с помощью `RETALT`. Двоеточие после `AGAINBRK` означает, что код цикла это весь оставшийся код в этом блоке (таким образом мы немного экономим на неявном `PUSHCONT`, который выполняют обычные циклы).

Когда TVM кидает исключение, она выкидывает весь старый стек и вместо него кладет два элемента -- код и параметр исключения. Нам они не нужны, поэтому мы их просто выкидываем с помощью `2DROP`.

Такое решение набирает **5.421** баллов и ест **1486287** газа.

### Идея 3
Зачем нам хранить стек dfs в тупле, когда у TVM уже есть свой нативный стек? Давайте прямо на нем и будем хранить ячейки.

Это приводит к следующему решению:
```
cell solution(int hash, cell cur) asm """
    SWAP // cur hash
    <{  AGAINBRK:
        // ... cur hash
        OVER HASHCU OVER EQUAL 
        IFJMP:<{
            DROP
            1 PUSHINT ONLYTOPX
            RETALT
        }>
        SWAP CTOS // ... hash cs
        DUP SREFS
        REPEAT:<{
            LDREF // ... hash ref cs
            s1 s2 XCHG
        }>
        DROP // ... hash
    }>CONT
    <{ 2DROP	
       <b b> PUSHREF
    }>CONT
    TRY
""";
```

Тут нужные нам переменные мы храним на верхушке стека, а под ними стек ячеек для dfs (обозначены троеточием в комментариях). Для того, чтобы вернуть найденную ячейку, нам нужно избавиться от всего оставшегося стека dfs -- для этого используем примитив `ONLYTOPX`.

Такое решение набирает **5.488** баллов и ест **1232129** газа.

### Идея 4
У нас в предыдущем решении есть `IFJMP:<{`, который проводит манипуляции со стеком, а затем вызывает `RETALT`. Но в TVM есть замечательный примитив `IFRETALT`, давайте лучше его используем. Это приводит к следующему решению:

```
cell solution(int hash, cell cur) asm """
    SWAP // cur hash
    <{  AGAINBRK:
        // ... cur hash
        OVER HASHCU OVER EQUAL IFRETALT
        SWAP CTOS // ... hash cs
        DUP SREFS
        REPEAT:<{
            LDREF // ... hash ref cs
            s1 s2 XCHG
        }>
        DROP // ... hash
    }>CONT
    <{ 2DROP
       <b b> PUSHREF PUSHNULL
    }>CONT
    TRY

    DROP 1 PUSHINT ONLYTOPX
""";
```

Тут нужные манипуляции со стеком мы проводит после `try-catch` блока. Первый `DROP` должен выбросить `hash` со стека, если мы действительно вышли по `IFRETALT`. Но так как мы могли выйти также и по исключению, мы в обработчике исключений выравниваем стек с помощью `PUSHNULL`, помещая `null` на место `hash`.

Такое решение набирает **5.497** баллов и ест **1201065** газа.

### Идея 5
Давайте сохраним хеш в глобальную переменную и будет доставть его только когда он понадобится, чтобы он не мешался на стеке. Это приводит нас к совсем красивенькому решению:

```
cell solution(int hash, cell cur) asm """
    SWAP // cur hash
    1 SETGLOB
    <{  AGAINBRK:
        // ... cur
        DUP HASHCU 1 GETGLOB EQUAL IFRETALT
        CTOS // ... cs
        DUP SREFS
        REPEAT:<{
            LDREF // ... ref cs
        }>
        DROP // ...
    }>CONT
    <{ 2DROP	
       <b b> PUSHREF
    }>CONT
    TRY 
    1 PUSHINT ONLYTOPX
""";
```

Оно набирает **5.523** баллов и ест **1114627** газа.

### Идея 6
Давайте попробуем поменять `REPEAT:<{` на `REPEAT:`, перенеся последний `DROP` в начало цикла. Для этого перед циклом нужно добавить `PUSHNULL`, чтобы выровнять стек:

```
cell solution(int hash, cell cur) asm """
    // hash cur
    SWAP 1 SETGLOB PUSHNULL
    <{  AGAINBRK:
        // ... cur
        DROP DUP HASHCU 1 GETGLOB EQUAL IFRETALT
        CTOS // ... cs
        DUP SREFS
        REPEAT: LDREF 
    }>CONT
    <{ 2DROP	
       <b b> PUSHREF
    }>CONT
    TRY 
    1 PUSHINT ONLYTOPX
""";
```

Пока я не пришел к идеи 7, это было финальным решением, которое набирает **5.544** баллов и ест **1043979** газа.

### Идея 7 (финальное решение)
Если внимательно посмотреть на наш код и подумать, от какой инструкции внутри цикла можно избавиться, то единственным вариантом окажется `IFRETALT`. Мы бы могли заменить наш цикл на `UNTIL:`, который автоматически проверит флажок со стека, если мы оставим его наверху. Но для этого нужно будет перенести проверку хеша ячейки `... EQUAL` в конец цикла. Сделаем это:

```
// hash cur
SWAP // cur hash

OVER HASHCU OVER EQUAL
IFJMP:<{ DROP }>

// cur hash
1 SETGLOB
<{  UNTIL:
    // ... cur
    CTOS // ... cs
    DUP SREFS
    REPEAT:<{ LDREF }>
    // ... cs
    DROP DUP HASHCU 1 GETGLOB EQUAL 
}>CONT
<{ 2DROP	
    <b b> PUSHREF
}>CONT
TRY 
1 PUSHINT ONLYTOPX
```

Тут появилась дополнительная проверка хеша корня дерева, поскольку в цикле мы теперь его не проверим. Мы избавились от `IFRETALT`, однако теперь снова используется `REPEAT:<{`, а не `REPEAT:`. Таким образом, мы делаем лишний `PUSHCONT` с нашим единственным `LDREF`. Однако `PUSHCONT` оказывается немного дешевле `IFRETALT`, так что такое решение оправдывает себя.

Оно набирает **5.548** баллов и ест **1033848** газа.

### Идея 8 (не дает улучшения)
`PUSHINT` для больших чисел на 3 единицы газа дешевле `1 GETGLOB`. Если бы хеш был известен во время компиляции, мы бы могли немного удешевить итерацию цикла с помощью этого. Но TVM может преобразовывать слайсы в исполняемый код прямо в рантайме (с помощью `BLESS`). Таким образом можно собрать код для нашего цикла уже во время исполнения, когда значение хеша известно.

Это приводит к такому решению:
```
cell solution(int hash, cell cur) asm """
    <{  PUSHNULL
        AGAINBRK:
        // ... cur cs
        DROP DUP HASHCU 
    }>s x{82F0} |+ constant pref

    <{  EQUAL IFRETALT
        CTOS // ... cs
        DUP SREFS
        REPEAT: LDREF 
    }>s constant suff

    // hash cur
    SWAP 
    pref PUSHSLICE 
    NEWC STSLICE
    256 STU
    suff PUSHSLICE STSLICER
    ENDC CTOS BLESS
    <{ 2DROP	
       <b b> PUSHREF
    }>CONT
    TRY 
    1 PUSHINT ONLYTOPX
""";
```

К сожалению, оно оказывается хуже, поскольку сборка кода использует слишком дорогой ENDC, который не окупается экономией на итерациях цикла.